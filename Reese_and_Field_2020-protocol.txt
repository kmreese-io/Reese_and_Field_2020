########################################################################################
## A FREE AND OPEN-SOURCE FUTURE-PROOF PROTOCOL FOR EFFECTIVE UAV-BASED ARCHAEOLOGICAL SURVEY
## KELSEY M. REESE AND SEAN FIELD
## JOURNAL OF COMPUTER APPLICATIONS IN ARCHAEOLOGY

###########################################
# PRE-FIELD PROCESS


# Install Homebrew, Docker, OpenDroneMap, and dependencies


/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
brew cask install docker
brew install python2
pip2 install --upgrade pip setuptools
pip2 install matplotlib psycopg2 requests future jinja2 pygments
brew install git
brew install r
git clone https://github.com/OpenDroneMap/OpenDroneMap.git
cd OpenDroneMap


# Open R and set repository for packages that will be installed


R
r  <-  getOption('repos')
r['CRAN']  <-  'http://cran.us.r-project.org'
options(repos = r)


# Install and load all necessary packages.


install.packages(c('sp','Hmisc','rgeos','rgdal','raster','scales','splancs','graphics','grDevices','FedData','RColorBrewer','spatialEco'))
library('sp');library('Hmisc');library('rgeos');library('rgdal');library('raster');library('scales');library('splancs');library('graphics');library('grDevices');library('FedData');library('RColorBrewer');library('spatialEco')


# Create and set directory for the project.


dir.create('Users/USERNAME/Documents/PATH/TO/PROJECT/',recursive=T,showWarnings=F)
set.wd('Users/USERNAME/Documents/PATH/TO/PROJECT/')


# Define the projection systems to be used. 'master.projection' should be set to your projection system that uses UTMs, and 'longlat.projection' should be kept as is. 


master.projection <- sp::CRS('+proj=YOUR +datum=PROJ4 +zone=HERE')
longlat.projection <- sp::CRS('+proj=longlat +datum=WGS84 +ellps=WGS84')


# A shapefile of your study area. Place shapefile in the working directory before running.


study.area <- rgdal::readOGR('./',layer='study_area_shapefile')
projection(study.area) <- master.projection
longlat.study.area <- sp::spTransform(study.area,longlat.projection)


# Federal DEM and Landcover data. Internet connection is required to run this chunk for the first time.


longlat.dem <- FedData::get_ned(longlat.study.area,label='study.area.dem',res=13,force.redo=F)
longlat.landcover <- FedData ::get_nlcd(longlat.study.area,label='study.area.landcover',force.redo=F)
dem <- raster::projectRaster(longlat.dem,crs=master.projection)
landcover <- raster::projectRaster(longlat.landcover,crs=master.projection)


# Define the area to be covered per flight. Currently set for 1 hectare, or 0.01 km2. A general rule of thumb is 2.25 minutes of flight per 1 hectare. If using DroneDeploy, the UAV will automatically return to home base for a new battery if the area is larger than what can be collected within a single flight.


flight.time.minutes <- 15
hectares.per.battery <- flight.time.minutes / 2.25
flight.area <- c(sqrt(hectares.per.battery*10000),sqrt(hectares.per.battery*10000))


# Define UAV flight polygons to use in DroneDeploy


grid.points <- makegrid(study.area,cellsize=flight.area)
spatial.grid <- SpatialPoints(grid.points,proj4string=master.projection)
spatial.grid.survey <- SpatialPixels(spatial.grid[study.area,])
survey.polygons <- as(spatial.grid.survey,'SpatialPolygons')
IDs <- sapply(slot(survey.polygons,'polygons'), function(x) slot(x,'ID'))
df <- data.frame(rep(0,length(IDs)),row.names=IDs)
UAV.polygons <- SpatialPolygonsDataFrame(survey.polygons,df)


# Landcover values: Water (10s); Developed (20s); Barren (30s); Forest (40s); Shrubland (50s); Harbaceous (70s); Planted/Cultivated (80s); Wetlands (90s)
# https://www.mrlc.gov/data/legends/national-land-cover-database-2011-nlcd2011-legend
# Adjust values as necessary based on your own study area, if necessary. Values provided here are generalized. The higher the values, the more visible the ground surface.


landcover.study.area <- trunc(raster::mask(landcover,accessible.survey.land))
landcover.study.area[landcover.study.area > 30 & landcover.study.area < 39] <- 5
landcover.study.area[landcover.study.area > 50 & landcover.study.area < 59] <- 4
landcover.study.area[landcover.study.area > 70 & landcover.study.area < 79] <- 3
landcover.study.area[landcover.study.area > 80 & landcover.study.area < 89] <- 2
landcover.study.area[landcover.study.area > 40 & landcover.study.area < 49] <- 1
landcover.study.area[landcover.study.area > 5] <- 0


# Calculate landcover values per survey square, add to SpatialPolygonDataFrame, and save polygons.
# All polygons in the exported 'UAV_survey_polygons' shapefile should produce reasonable results.


survey.square.values <- raster::extract(landcover.study.area,UAV.polygons)
survey.square.sum <- lapply(1:length(survey.square.values),FUN=function(x,...) {base::sum(survey.square.values[[x]])} )
survey.square.values <- extract(landcover.study.area,UAV.polygons)
survey.square.sum <- lapply(1:length(survey.square.values),FUN=function(x,...) {sum(survey.square.values[[x]])} )
survey.square.sum.unlist <- base::unlist(survey.square.sum)
survey.square.sum.unlist[is.na(survey.square.sum.unlist)] <- 0
UAV.polygons$landcover.value <- base::unlist(survey.square.sum.unlist)
UAV.survey.polygons <- UAV.polygons[which(UAV.polygons$landcover.value >= 35 ),]
rgdal::writeOGR(UAV.survey.polygons,'./',layer='UAV_survey_polygons',driver='ESRI Shapefile')


# Select the polygons for flight, and export each polygon. Send to UAV remote equipped with DroneDeploy and define flight height parameters for each polygon.


## Example: how to pick polygons based on landcover value.


polygon.landcover <- UAV.survey.polygons[which(UAV.survey.polygons$landcover.value == max(UAV.survey.polygons$landcover.value)),]
rgdal::writeOGR(polygon.landcover,'./',layer='polygon_landcover',driver='ESRI Shapefile')


## Example: how to pick polygons based on coordinates. Change *.csv file and column names to your own.


example.coordinates <- utils::read.csv('./datums.csv')
datums <- sp::SpatialPointsDataFrame(coords=as.matrix(base::cbind(example.coordinates$Easting,example.coordinates$Northing)),example.coordinates,proj4string=master.projection)
projection(UAV.survey.polygons) <- master.projection
polygon.coordinates <- UAV.survey.polygons[datums,]
rgdal::writeOGR(polygon.coordinates,'./',layer='polygon_coordinates',driver='ESRI Shapefile')


# Export each polygon for flight.
# Download the DroneDeploy application to your UAV remote and save the flight polygons to the remote.
# Import each polygon to the DroneDeploy application and set up flight parameters.
# Specific instructions on how to use DroneDeploy and Frequently Asked Questions are available on the application's website (https://www.dronedeploy.com/).


###########################################
# IN-FIELD PROCESS


# Arrive at the selected polygon in the field and move to the highest elevation in the polygon.
# Set up the UAV for flight, start DroneDeploy, and launch the UAV via the intended DroneDeploy flight plan.
# PRO TIP: at the beginning of each flight, DroneDeploy will take one image before leaving the ground. To make it easier to identify which images belong to which flight, especially when making multiple flights per day, it is handy to have a small dry-erase board on-hand to write identifying information about the flight, which can be easily recognized later to make sure all images for a collection area are later used in the terrain model.
# Wait for each image collection process to finish. The UAV will automatically return to its launch position when it is either getting too low on battery or when it is done collecting all images in the flight plan.


###########################################
# POST-FIELD PROCESS


# Open Terminal, create directory for collected images in your project folder, move images into that folder, open and run OpenDroneMap.


cd ~/Documents
mkdir PATH/TO/PROJECT/images


# Place orthophoto images in 'images' folder within project path


# Open Docker, a dependency for OpenDroneMap. Increase the amount of RAM available to Docker under settings, if necessary.


open -a docker


# The parameters outlined here tell OpenDroneMap to produce the highest-resolution Digital Terrain and Elevation models based on the provided images.
# A full list of parameters for OpenDroneMap are available here: https://github.com/OpenDroneMap/ODM/wiki/Run-Time-Parameters


docker run -ti --rm -v /Users/USERNAME/Documents/PATH/TO/PROJECT:/datasets/code opendronemap/odm --project-path /datasets --dtm --dem-resolution 0.0001 --time --skip-3dmodel


# The Digital Terrain Model (DTM) will be available in /Users/USERNAME/Documents/PATH/TO/PROJECT/odm_dem/dtm.tif
# The DTM can then be opened in you GIS of choice (R, QGIS, etc.) and used for terrain analyses



